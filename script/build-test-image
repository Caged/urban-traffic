#!/usr/bin/env node
require('dotenv').config()

const fs = require('fs')
const { createCanvas } = require('canvas')
const d3 = require('d3')
const d3Tile = require('d3-tile')
const fetch = require('node-fetch')

const width = 256 * 6
const height = width

const out = fs.createWriteStream('out.png')
const canvas = createCanvas(width, height)
const ctx = canvas.getContext('2d')

ctx.fillStyle = '#fff'
ctx.rect(0, 0, width, height)
ctx.fill()

// Based on https://observablehq.com/@d3/vector-tiles
const projection = d3
  .geoMercator()
  .center([-122.681944, 45.52])
  .scale((1 << 21) / (2 * Math.PI))
  .translate([width / 2, height / 2])

const tile = d3Tile
  .tile()
  .size([width, height])
  .scale(projection.scale() * 2 * Math.PI)
  .translate(projection([0, 0]))

const path = d3.geoPath(projection).context(ctx)

const tileData = Promise.all(
  tile().map(async d => {
    d.data = await fetch(
      `https://tile.nextzen.org/tilezen/vector/v1/256/all/${d.z}/${d.x}/${
        d.y
      }.json?api_key=${process.env.NEXTZEN_API_KEY}`
    ).then(response => response.json())
    return d
  })
)

tileData.then(tiles => {
  tiles.map(d => {
    ctx.beginPath()
    ctx.strokeStyle = '#aaa'
    path({
      type: 'FeatureCollection',
      features: d.data.water.features.filter(d => d.properties.boundary)
    })
    ctx.stroke()

    ctx.beginPath()
    ctx.strokeStyle = '#ccc'
    path(d.data.roads)
    ctx.stroke()
  })

  canvas.pngStream().pipe(out)
})
